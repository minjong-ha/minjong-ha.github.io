---
layout: posts
title:  "eBPF"
author: Minjong Ha
published: false
date:   2022-03-01 12:00:00 +0900
---

I have an interest in 'eBPF'.
Let's figure it out.

## Introduction

### BPF

'BPF (Berkely Packet Filter)' is an in-kernel virtual machine that analyzing packets with packet fileter.
BPF has virtual registers and stack and execute codes based on it.
JIT (Just In-Time) compiler makes BPF commands run directly on the processor.

<img data-action="zoom" src='{{ "../assets/images/posts/2023-03-01-eBPF/how_bpf_vs_ebpf.png" | relative_url }}' alt='relative'>

Above figure represents how BPF works.
BPF executes the program on the pre-defined hook inside the kernel or kprobe, uprobe, and tracepoint.
In figure, it runs BPF program every time execve system call is called.
The point is, you can run such program inside the certain points of kernel.

### eBPF

<img data-action="zoom" src='{{ "../assets/images/posts/2023-03-01-eBPF/bpf_vs_ebpf.png" | relative_url }}' alt='relative'>

'eBPF (extended BPF)' takes one more step.
It has larger register, stack and map.
It also does not require additional kernel source code modification and module.
It supports multiple map types such as hash table, LRU, ring buffer, stack trace and etc.

It is possible compile C program to eBPF with Android build system.

```c
#include <linux/bpf.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <linux/ip.h>
#include <linux/in.h>

int count_packets(struct __sk_buff *skb) {
    struct ethhdr *eth = NULL;
    struct iphdr *ip = NULL;

    eth = (struct ethhdr *)(skb->data);
    if (eth->h_proto != htons(ETH_P_IP)) {
        return 0;
    }

    ip = (struct iphdr *)(skb->data + sizeof(struct ethhdr));
    if (ip->version != 4) {
        return 0;
    }

    if (ip->protocol == IPPROTO_TCP || ip->protocol == IPPROTO_UDP) {
        bpf_trace_printk("Packet received on interface %d\n", skb->ifindex);
        return 1;
    }

    return 0;
}

char _license[] SEC("license") = "GPL";
unsigned int _version SEC("version") = LINUX_VERSION_CODE;
struct bpf_map_def SEC("maps") packet_count = {
    .type = BPF_MAP_TYPE_ARRAY,
    .key_size = sizeof(int),
    .value_size = sizeof(long long),
    .max_entries = 1,
};
SEC("socket")
int packet_counter(struct __sk_buff *skb) {
    long long *value;

    if (count_packets(skb)) {
        value = bpf_map_lookup_elem(&packet_count, &skb->ifindex);
        if (value) {
            (*value)++;
        }
    }

    return 0;
}
```



## Reference
[[Linux Kernel] What is BPF/eBPF?](https://hyeyoo.com/133)
[ebpf.io](https://ebpf.io/)
[Learn eBPF Tracing: Tutorial and Examples](https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html)

