---
layout: posts
title:  "Benchmark Debian OS on raspberry pi with PREEMPT\_RT patch kernel"
author: Minjong Ha
published: true
date:   2023-09-07 14:38:07 +0900
---

This post introduces the comparison about the latencies between `PREEMPT_RT` and `mainline` linux kernel.

## Introduection

In previous post, I installed `PREEMPT_RT` kernel on Debian 12 in raspberry pi.
Considering that the major characteristic of embedded machine is real-time, Comparing its latencies with `mainline` linux kernel is essential.

I benchmarked the latencies of `PREEMPT_RT` and `mainline` linux kernel with `cyclictest` in [`rt-tests`](https://git.kernel.org/pub/scm/utils/rt-tests/rt-tests.git/).
Then I visualize the results in three formats: tail latencies, cumulative distribution figure (CDF), and flowchart of test results.
Visualized figures are generated by `pyplot` from `matplotlib` in `python`.

## Experiment

I use `Raspberry pi 3B+` (`raspi 3b+`) machine for experiment.

```
- Broadcom BCM2837B0, Cortex-A53 (ARMv8) 64-bit SoC @ 1.4GHz
- 1GB LPDDR2 SDRAM
- 5V/2.5A DC power input
- Debian 12
- Linux kernel 6.1.46 / Linux kernel 6.1.46-rt14-rc1
```

You can check details about `Debian 12 raspi 3b+` on my previous post.

I use `cyclictest` in `rt-tests` to measure the latencies between `mainline` and `preempt_rt` kernel.
Followings are the commands that being used for benchmark:

```
sudo cyclictest -l1000000 -q -v -p80 -a0   
sudo cyclictest -l1000000 -q -v -p80 -t -a 
sudo cyclictest -l1000000 -q -v -p80 -t16 -a 
```

Each commands represents the scenario: 1:1, N:N, and M:N (M > N).
`1:1` scenario assumes there is only one thread for one processor.
`N:N` scenario assumes there are N threads for N processors and each processors only executes one thread.
`M:N` scenario assumes there are M threads for N processors and each processors should switch its executing threads.

Each tests measures 1,000,000 latencies and each scenarios measures 10 tests (total 10,000,000 latencies are measured by each scenarios).
I visualize the results of each scenarios between `mainline` and `preempt_rt` kernel.

### Tail Latencies

![tail\_latencies\_1:1](/assets/images/posts/2023-09-07-raspi-debian-benchmark/tail_latency_1:1.png)

Above figure represents the tail latencies between two kernels in `1:1` scenario.
`preempt_rt` has worse throughput with average latencies than `mainline`.
However, while `mainline` has exploding latencies from `99.999%` latency, `preempt_rt` has stable latencies.
`99.999%` latency means the maximum latency for `99.999%` in total measurements.


![tail\_latencies\_N:N](/assets/images/posts/2023-09-07-raspi-debian-benchmark/tail_latency_N:N.png)

This tendency becomes more pronounced as the number of processing increases.
Second figure assumes `N:N` scenario and represents its tail latencies.
Average throughput and latency is better in `mainline` than `preempt_rt`.
However, `mainline` now shows much higher tail latencies from `99.999%`.

![tail\_latencies\_4N:N](/assets/images/posts/2023-09-07-raspi-debian-benchmark/tail_latency_4N:N.png)

Third figures assumes `M:N` scenario and represents its tail latencies.
Now `mainline` has more than 2,000 us latency in `99.999%` which is twice longer than `mainline` in `N:N` scenario and 3 times longer than `mainline` in `1:1` scenario.

### CDF

![cdf\_1:1](/assets/images/posts/2023-09-07-raspi-debian-benchmark/cdf_1:1.png)
![cdf\_N:N](/assets/images/posts/2023-09-07-raspi-debian-benchmark/cdf_N:N.png)
![cdf\_4N:N](/assets/images/posts/2023-09-07-raspi-debian-benchmark/cdf_4N:N.png)


Above figures represents same tail latencies but in Cumulative Distribution Figure (CDF).
It sorts all latencies and calculates its cumulative proportions.
The orange line of `mainline` is located on left side of blue line of `preempt_rt` and it represents that more latencies has lower value than `preempt_rt`.
However, while `preempt_rt` only has its worst latency as 203 us, `mainline` has 7 times to 25 times longer latency in worst case.

### Flowchart

![flowchart\_1:1](/assets/images/posts/2023-09-07-raspi-debian-benchmark/flowchart_1:1.png)
![flowchart\_N:N](/assets/images/posts/2023-09-07-raspi-debian-benchmark/flowchart_N:N.png)
![flowchart\_4N:N](/assets/images/posts/2023-09-07-raspi-debian-benchmark/flowchart_4N:N.png)

Above figures represents latencies during the test.
Since it is hard to understand for total latencies, I choose random test for each scenarios and compare them.
All scenarios show same tendency: `mainline` jittering while `preempt_rt` does not.

Considering the important characteristic of embedded system is `realtime`, `mainline`'s long tail latency could violate maximum limit for `realtime` tasks.
